<!DOCTYPE html>
<html>

<head>
  <title>Библиотека знаний (язык DSL)</title>
  <style>
  * {
   font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
   font-size: 15px;
  }
  body {
	background: #F5F6F8;
  }
  p {
    margin-left: 20px;
  }
  </style>
</head>
<body lang="ru">
  <p>DSL (Domain-Specific Language) — это язык программирования (можно рассматривать как "язык в языке"), разработанный для решения задач в определенной области. В отличие от языков общего назначения (например: Python, Java, C++), которые предназначены для широкого круга задач, DSL ориентирован на конкретную задачу или домен. Обычно пишется на интерпретируемом языке и сам интерпретируется.</p>
  
  <p>Основные характеристики DSL:</p>
  <ul>
    [•]&nbsp;&nbsp;Ограниченная область применения: DSL решает задачи только в своей области.<br>
    [•]&nbsp;&nbsp;Выразительность: DSL должен быть выразительным в своей области, то есть позволять легко и понятно описывать задачи.<br>
    [•]&nbsp;&nbsp;Легкость в изучении и использовании: DSL должен быть простым в изучении и использовании для экспертов в данной области, даже если они не являются профессиональными программистами.
  </ul>
  <p>DSL реализуется как встроенный (internal), либо как внешний (external) модуль/пакет:</p>
  <ul>
    [•]&nbsp;&nbsp;Встроенный DSL (Internal DSL):<br>
    [•]&nbsp;&nbsp;Реализуется внутри существующего языка программирования (хост-языка).<br>
    [•]&nbsp;&nbsp;Использует синтаксис и возможности хост-языка.<br>
    [•]&nbsp;&nbsp;DSL-код является валидным кодом на хост-языке.<br>
    [•]&nbsp;&nbsp;Реализация часто включает в себя использование библиотек, функций, классов и перегрузку операторов хост-языка для создания DSL-подобного синтаксиса.<br>
    [•]&nbsp;&nbsp;Пример: JUnit (для написания тестов на Java). Код тестов выглядит как DSL, но на самом деле является обычным Java-кодом, использующим возможности JUnit.<br>
    [•]&nbsp;&nbsp;Интерпретация: Код DSL выполняется интерпретатором (или компилятором) хост-языка (т.е. нет отдельного интерпретатора для DSL).<br>
    [•]&nbsp;&nbsp;Внешний DSL (External DSL):<br>
    [•]&nbsp;&nbsp;Является отдельным языком со своим синтаксисом и грамматикой.<br>
    [•]&nbsp;&nbsp;Требует собственного парсера и интерпретатора (или компилятора).<br>
    [•]&nbsp;&nbsp;DSL-код не является валидным кодом на хост-языке.<br>
    [•]&nbsp;&nbsp;Реализация включает в себя создание грамматики DSL, написание парсера для разбора кода DSL и интерпретатора (или компилятора) для выполнения DSL-кода.<br>
    [•]&nbsp;&nbsp;Пример: SQL (для работы с базами данных).<br>
    [•]&nbsp;&nbsp;Интерпретация: Код DSL сначала парсится парсером, который генерирует абстрактное синтаксическое дерево (AST). Затем интерпретатор (или компилятор) обходит это дерево и выполняет соответствующие действия.<br>
  </ul>
  <p>Чаще всего DSL интерпретируются, но не всегда:</p>
  <ul>
    [•]&nbsp;&nbsp;Интерпретация: Многие внешние DSL реализуются с использованием интерпретаторов. Интерпретатор выполняет код DSL построчно (или, точнее, обходя AST). Это проще в реализации и позволяет быстро разрабатывать DSL.<br>
    [•]&nbsp;&nbsp;Компиляция: Некоторые DSL компилируются в байт-код (как мы обсуждали ранее) или даже в машинный код. Это позволяет достичь более высокой производительности, но требует более сложной реализации. Например, некоторые шаблонизаторы компилируются в PHP код, который потом выполняется PHP-интерпретатором.<br>
    [•]&nbsp;&nbsp;Транспиляция: DSL может быть транспилирован в код на другом языке (например, JavaScript, Python или др. языки). Этот подход позволяет использовать существующие инструменты и библиотеки целевого языка.
  </ul>
  <p>Интерпретируемый хост-язык (частый случай):</p>
  <ul>
    [•]&nbsp;&nbsp;Часто, но не всегда, DSL создаются на основе интерпретируемых языков (например: Python, Ruby, JavaScript, PHP).<br>
    [•]&nbsp;&nbsp;Это связано с тем, что интерпретируемые языки обычно предоставляют больше гибкости и динамических возможностей, что упрощает разработку DSL.<br>
    [•]&nbsp;&nbsp;Однако, DSL также можно создавать на основе компилируемых языков (например: C++, Java), хотя это может потребовать больше усилий.
  </ul>
  <p>Примеры DSL-языков:</p>
  <ul>
    [•]&nbsp;&nbsp;SQL: Для работы с базами данных.<br>
    [•]&nbsp;&nbsp;Regular expressions: Для поиска и обработки текста.<br>
    [•]&nbsp;&nbsp;Gradle (Groovy DSL): Для сборки Java-проектов.<br>
    [•]&nbsp;&nbsp;CSS: Для стилизации веб-страниц.<br>
    [•]&nbsp;&nbsp;HTML: Для разметки веб-страниц (хотя некоторые спорят, что это не совсем DSL, а скорее язык разметки).<br>
    [•]&nbsp;&nbsp;Makefiles: Для автоматизации сборки программ.
  </ul>
  <p>В большинстве случаев DSL — это "язык в языке", который либо встраивается в существующий язык (внутренний DSL), либо является отдельным языком, который обычно интерпретируется (внешний DSL). Интерпретируемый хост-язык часто используется для разработки DSL из-за его гибкости. Однако, существуют и компилируемые DSL.</p>
  
  <p>DSL могут быть скомпилированы в машинный код (редко), но транспиляция – гораздо более распространенный и практичный подход. Разбор по пунктам:</p>
  
  <p>1. Типы обработки DSL-кода:</p>
   
  <p>1.1 Интерпретация (условно чистая):</p>
  <ul>
    [•]&nbsp;&nbsp;DSL-код напрямую выполняется интерпретатором (например, в случае Brainfuck – посимвольно).<br>
    [•]&nbsp;&nbsp;Не требует предварительной компиляции или транспиляции.<br>
    [•]&nbsp;&nbsp;Требует написания интерпретатора, который умеет понимать и выполнять DSL-инструкции.<br>
    [•]&nbsp;&nbsp;Этот подход часто используется для простых DSL, где не требуется высокая производительность.
  </ul>
  <p>1.2 Транспиляция:</p>
  <ul>
    [•]&nbsp;&nbsp;DSL-код преобразуется в эквивалентный код на другом языке программирования (например: JavaScript, Python, PHP).<br>
    [•]&nbsp;&nbsp;Требует написания транспилятора, который выполняет это преобразование.<br>
    [•]&nbsp;&nbsp;Сгенерированный код затем выполняется интерпретатором или компилятором целевого языка.<br>
    [•]&nbsp;&nbsp;Этот подход позволяет использовать существующие инструменты и библиотеки целевого языка, а также обеспечивает лучшую производительность по сравнению с чистой интерпретацией.
  </ul>
  <p>1.3 Компиляция (условно промежуточная) в байт-код:</p>
  <ul>
    [•]&nbsp;&nbsp;DSL-код преобразуется в байт-код, который затем выполняется виртуальной машиной (VM).<br>
    [•]&nbsp;&nbsp;Требует написания компилятора для преобразования DSL-кода в байт-код и виртуальной машины для выполнения байт-кода.<br>
    [•]&nbsp;&nbsp;Этот подход обеспечивает переносимость (если VM реализована для разных платформ) и позволяет оптимизировать выполнение кода.
  </ul>
  <p>1.4 Компиляция (условно прямая) в машинный код:</p>
  <ul>
    [•]&nbsp;&nbsp;DSL-код преобразуется непосредственно в машинный код, который выполняется процессором.<br>
    [•]&nbsp;&nbsp;Требует написания компилятора, который выполняет эту сложную задачу.<br>
    [•]&nbsp;&nbsp;Этот подход обеспечивает максимальную производительность, но является наиболее сложным в реализации и наименее переносимым.
  </ul>
  <p>2. Разбор программы (необходимость):</p>
  
  <p>Независимо от того, какой подход используется (интерпретация, транспиляция, компиляция), разбор DSL-кода является необходимым шагом. Разбор включает в себя:</p>
  
  <p>2.1 Лексический анализ (Lexical Analysis):</p>
  <ul>
    [•]&nbsp;&nbsp;Преобразует входной поток символов в последовательность токенов (лексем).<br>
    [•]&nbsp;&nbsp;Токен — это минимальная значимая единица языка (например, ключевое слово, идентификатор, число, оператор).<br>
    [•]&nbsp;&nbsp;Лексический анализатор обычно реализуется с использованием регулярных выражений или конечных автоматов.
  </ul>
  <p>2.2 Синтаксический анализ (Syntactic Analysis):</p>
  <ul>
    [•]&nbsp;&nbsp;Строит синтаксическое дерево (AST - Abstract Syntax Tree) на основе последовательности токенов.<br>
    [•]&nbsp;&nbsp;Синтаксическое дерево отражает грамматическую структуру программы.<br>
    [•]&nbsp;&nbsp;Синтаксический анализатор обычно реализуется с использованием контекстно-свободных грамматик и алгоритмов разбора (например, LL, LR).
  </ul>
  <p>2.3 Семантический анализ (Semantic Analysis):</p>
  <ul>
    [•]&nbsp;&nbsp;Проверяет смысловую корректность (нагрузку) программы.<br>
    [•]&nbsp;&nbsp;Выполняет проверки типов, разрешения имен, проверку областей видимости и другие семантические проверки.<br>
    [•]&nbsp;&nbsp;Добавляет информацию о типах и других семантических атрибутах в синтаксическое дерево.<br>
  </ul>
  <p>Обработка ошибок (вынесено в отдельный пункт, т.к. предусматривает работу на всех этапах компиляции):</p>
  <ul>
    [•]&nbsp;&nbsp;Обнаруживает и сообщает об ошибках в DSL-коде.<br>
    [•]&nbsp;&nbsp;Обработка ошибок может включать в себя вывод информативных сообщений об ошибках, указание местоположения ошибки и попытки восстановления после ошибок.
  </ul>
  <p>3. Встроенный DSL (Internal DSL) – исключение?</p>
  
  <p>Для встроенных DSL разбор DSL-кода выполняется хост-языком. Для этого не нужно писать отдельный парсер. Вместо этого, используются возможности хост-языка (библиотеки, функции, классы, перегрузку операторов) для создания DSL-подобного синтаксиса.</p>
  
  <p>Ситуация такова:</p>
  <ul>
    [•]&nbsp;&nbsp;Для внешних DSL обязательно нужно писать лексический анализатор, синтаксический анализатор и (обычно) семантический анализатор.<br>
    [•]&nbsp;&nbsp;Для встроенных DSL разбор выполняется хост-языком, и нет необходимости писать отдельные анализаторы.
  </ul>
  <p>Рассмотрим пример с языком Brainfuck, где каждый его символ является токеном, и интерпретатор обрабатывает каждый символ по очереди. Для встроенных DSL эта часть работы ложится на хост-язык. Далее представлен более развернутый ответ, подтверждающий и дополняющий эти тезисы:</p>
  
  <p>1. Преимущества разработки DSL на языке с богатой экосистемой (например: PHP):</p>
  
  <p>1.1 Ускоренная разработка и прототипирование:</p>
  <ul>
    [•]&nbsp;&nbsp;PHP (или Python, JavaScript, Ruby, Java и т.д.) предоставляет множество готовых библиотек и фреймворков для парсинга, лексического анализа, AST-манипуляций и генерации кода. Нет необходимости изобретать велосипед для этих базовых задач.<br>
    [•]&nbsp;&nbsp;Существующие инструменты для отладки, тестирования и профилирования значительно ускоряют процесс разработки DSL.<br>
    [•]&nbsp;&nbsp;Большое сообщество и обилие документации позволяют быстро находить решения для возникающих проблем.
  </ul>
  <p>1.2 Сокращение объема кода:</p>
  <ul>
    [•]&nbsp;&nbsp;Высокоуровневые языки позволяют выразить сложные концепции DSL в меньшем количестве строк кода по сравнению с низкоуровневыми языками, такими как C или даже Brainfuck.
  </ul>
  <p>1.3 Фокус на логике DSL:</p>
  <ul>
    [•]&nbsp;&nbsp;Использование языка с развитой инфраструктурой позволяет сосредоточиться на проектировании самого DSL и его функциональности, а не на низкоуровневых деталях реализации парсера и компилятора.<br>
  </ul>
  <p>2. Что можно сделать после создания DSL (транспиляция, компиляция, обучение нейросети):</p>
  
  <p>2.1 Транспиляция в другой язык: DSL может преобразовывать код, написанный на одном языке, в эквивалентный код на другом языке (например: в JavaScript, Python, SQL и др. языки). Это полезно для:</p>
  <ul>
    [•]&nbsp;&nbsp;Переносимости: Запускайте код DSL на разных платформах, где есть поддержка целевого языка.<br>
    [•]&nbsp;&nbsp;Интеграции: Интегрируйте код DSL с существующими системами, написанными на другом языке.<br>
    [•]&nbsp;&nbsp;Производительности: Транслируйте DSL в язык, скомпилированный в машинный код (например: C/C++), если требуется высокая производительность.
  </ul>
  <p>2.2 Компиляция в байт-код виртуальной машины: Создать свою собственную виртуальную машину (VM) или скомпилировать DSL в байт-код существующей VM (например: Java Virtual Machine (JVM) или .NET Common Language Runtime (CLR)). Это дает:</p>
  <ul>
    [•]&nbsp;&nbsp;Контроль над исполнением: Вы можете оптимизировать VM специально для вашего DSL.<br>
    [•]&nbsp;&nbsp;Безопасность: VM может обеспечивать изоляцию и контроль доступа.<br>
    [•]&nbsp;&nbsp;Переносимость: Код DSL может быть запущен на любой платформе, поддерживающей вашу VM.
  </ul>
  <p>2.3 Обучение нейросети: DSL может быть использован для описания архитектур нейронных сетей, функций потерь, алгоритмов оптимизации и т.д. Затем этот DSL может быть использован для:</p>
  <ul>
  [•]&nbsp;&nbsp;Автоматической генерации кода для обучения нейросетей: Например, генерация кода на TensorFlow или PyTorch.<br>
  [•]&nbsp;&nbsp;Экспериментирования с новыми архитектурами и алгоритмами: DSL позволяет быстро прототипировать и тестировать новые идеи.
  </ul>
  <p>3. Уровень абстракции DSL (высокоуровневый и низкоуровневый):</p>
  
  <p>3.1 Высокоуровневый DSL:</p>
  
  <p>Преимущества:</p>
  <ul>
    [•]&nbsp;&nbsp;Легче читать и писать код.<br>
    [•]&nbsp;&nbsp;Более выразительный: позволяет решать задачи в предметной области более естественно.<br>
    [•]&nbsp;&nbsp;Более безопасный: можно реализовать проверки типов и другие ограничения, чтобы предотвратить ошибки.<br>
    [•]&nbsp;&nbsp;Ускоряет разработку и поддержку.
  </ul>
  <p>Недостатки:</p>
  <ul>
    [•]&nbsp;&nbsp;Может быть сложнее в реализации (требуется больше усилий для парсинга, анализа и генерации кода).<br>
    [•]&nbsp;&nbsp;Может быть менее гибким, чем низкоуровневый DSL.<br>
  </ul>
  <p>3.2 Низкоуровневый DSL (например, Brainfuck):</p>
  <p>Преимущества:</p>
  <ul>
    [•]&nbsp;&nbsp;Простой в реализации.<br>
    [•]&nbsp;&nbsp;Может дать максимальный контроль над аппаратным обеспечением (в теории, но на практике почти никогда не используется для этой цели).
  </ul>
  <p>Недостатки:</p>
  <ul>
    [•]&nbsp;&nbsp;Очень сложно писать и отлаживать код.<br>
    [•]&nbsp;&nbsp;Низкая выразительность.<br>
    [•]&nbsp;&nbsp;Огромное количество кода требуется для решения даже простых задач.<br>
    [•]&nbsp;&nbsp;Замедляет разработку в разы.
  </ul>
  <p>Из этого следует:</p>
  
  <p>Начинать лучше всего с высокоуровневого DSL, реализованного на языке с богатой экосистемой (например: PHP, Python, JavaScript и др. языки), а затем, в зависимости от потребностей, можно либо транспилировать его в другой язык, либо скомпилировать в байт-код, либо использовать для обучения нейросетей. Низкоуровневые DSL, такие как Brainfuck, полезны только в очень специфических случаях (например: как учебный пример) и обычно не подходят для реальных задач.</p>
</body>

</html>